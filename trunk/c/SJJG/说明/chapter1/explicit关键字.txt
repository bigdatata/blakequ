c++ explicit关键字  

1、c++中的explicit关键字用来修饰类的构造函数，表明该构造函数是显式的，既然有"显式"那么必然就有"隐式"，那么什么是显示而什么又是隐式的呢？

如果c++类的构造函数有一个参数，那么在编译的时候就会有一个缺省的转换操作：将该构造函数对应数据类型的数据转换为该类对象，如下面所示：

class MyClass

{

public:

MyClass( int num );

}

....

MyClass obj = 10; //ok,convert int to MyClass

在上面的代码中编译器自动将整型转换为MyClass类对象，实际上等同于下面的操作：

MyClass temp(10);

MyClass obj = temp;

上面的所有的操作即是所谓的"隐式转换"。

如果要避免这种自动转换的功能，我们该怎么做呢？嘿嘿这就是关键字explicit的作用了，将类的构造函数声明为"显示"，也就是在声明构造函数的时候前面添加上explicit即可，这样就可以防止这种自动的转换操作，如果我们修改上面的MyClass类的构造函数为显示的，那么下面的代码就不能够编译通过了，如下所示：

class MyClass

{

public:

explicit MyClass( int num );

}

....

MyClass obj = 10; //err,can't non-explict convert

 

2、explicit关键字

　　我们在编写应用程序的时候explicit关键字基本上是很少使用,它的作用是"禁止单参数构造函数"被用于自动型别转换,其中比较典型的例子就是容器类型,在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数.

　　例如:
　　你可以声明这样一个构造函数


　　class Array
　　{
　　public:
　　explicit Array(int size);
　　......
　　};

　　在这里explicit关键字起着至关重要的作用,如果没有这个关键字的话,这个构造函数有能力将int转换成Array.一旦这种情况发生,你可以给Array支派一个整数值而不会引起任何的问题,比如:


　　Array arr;
　　...
　　arr = 40;

　　此时,C++的自动型别转换会把40转换成拥有40个元素的Array,并且指派给arr变量,这个结果根本就不是我们想要的结果.如果我们将构造函数声明为explicit,上面的赋值操作就会导致编译器报错,使我们可以及时发现错误.需要注意的是:explicit同样也能阻止"以赋值语法进行带有转型操作的初始化";
例如:
　　Array arr(40);//正确
　　Array arr = 40;//错误

　　看一下以下两种操作:
　　X x;
　　Y y(x);//显式类型转换
　　另一种
　　X x;
　　Y y = x;//隐式类型转换

　　这两种操作存在一个小小的差别,第一种方式式通过显式类型转换,根据型别x产生了型别Y的新对象;第二种方式通过隐式转换产生了一个型别Y的新对象.
　　explicit关键字的应用主要就是上面所说的构造函数定义种,参考该关键字的应用可以看看STL源代码,其中大量使用了该关键字